"""
This script generates the schema for the schema - e.g.
a definition of what inputs can be provided to `SchemaValidator()`.

The schema is generated from `pydantic_core/_types.py`.
"""
import re
import importlib.util
from pprint import pformat
from typing import List, Dict, Any, ForwardRef, Union
from collections.abc import Callable
from datetime import date, datetime, time
from pathlib import Path

from typing_extensions import is_typeddict, get_args

import black

try:
    from typing import get_origin
except ImportError:
    def get_origin(t):
        return getattr(t, '__origin__', None)

THIS_DIR = Path(__file__).parent
SAVE_PATH = THIS_DIR / 'src' / 'self_schema.py'

# can't import _types.py directly as pydantic-core might not be installed
core_types_spec = importlib.util.spec_from_file_location('_typing', str(THIS_DIR / 'pydantic_core' / '_types.py'))
core_types = importlib.util.module_from_spec(core_types_spec)
core_types_spec.loader.exec_module(core_types)

# the validator for referencing schema (Schema is used recursively, so has to use a reference)
schema_ref_validator = {'type': 'recursive-ref', 'schema_ref': 'root-schema'}


def get_schema(obj):
    if isinstance(obj, str):
        return obj
    elif obj in (datetime, date, time, bool, int, float, str):
        return obj.__name__
    elif is_typeddict(obj):
        return type_dict_schema(obj)
    elif obj == Any:
        return 'any'
    elif obj == type:
        # todo
        return 'any'

    origin = get_origin(obj)
    assert origin is not None, f'origin cannot be None, obj={obj}'
    if origin is Union:
        return union_schema(obj)
    elif obj is Callable or origin is Callable:
        # todo
        return 'any'
    elif origin is core_types.Literal:
        return {'type': 'literal', 'expected': all_literal_values(obj)}
    elif issubclass(origin, List):
        return {'type': 'list', 'items_schema': get_schema(obj.__args__[0])}
    elif issubclass(origin, Dict):
        return {
            'type': 'dict',
            'keys_schema': get_schema(obj.__args__[0]),
            'values_schema': get_schema(obj.__args__[1]),
        }
    else:
        # debug(obj)
        raise TypeError(f'Unknown type: {obj!r}')


def type_dict_schema(typed_dict):
    required_keys = typed_dict.__required_keys__
    fields = {}
    if typed_dict.__name__ == 'Schema':
        return {'type': 'typed-dict', 'fields': fields}

    for field_name, field_type in typed_dict.__annotations__.items():
        required = field_name in required_keys
        schema = None
        if type(field_type) == ForwardRef:
            fr_arg = field_type.__forward_arg__
            if 'Schema' == fr_arg or '[Schema]' in fr_arg:
                fr_arg, matched = re.subn(r'Required\[(.+)]', r'\1', fr_arg)
                if matched:
                    required = True

                fr_arg, matched = re.subn(r'NotRequired\[(.+)]', r'\1', fr_arg)
                if matched:
                    required = False

                if fr_arg == 'Schema':
                    schema = schema_ref_validator
                elif fr_arg == 'List[Schema]':
                    schema = {'type': 'list', 'items_schema': schema_ref_validator}
                else:
                    raise ValueError(f'Unknown Schema forward ref: {fr_arg}')
            else:
                field_type = eval_forward_ref(field_type)

        if schema is None:
            if get_origin(field_type) == core_types.Required:
                required = True
                field_type = field_type.__args__[0]
            if get_origin(field_type) == core_types.NotRequired:
                required = False
                field_type = field_type.__args__[0]

            schema = get_schema(field_type)

        fields[field_name] = {'schema': schema, 'required': required}

    return {'type': 'typed-dict', 'description': typed_dict.__name__, 'fields': fields}


def union_schema(union_type):
    return {'type': 'union', 'choices': [get_schema(arg) for arg in union_type.__args__]}


def all_literal_values(type_):
    values = get_args(type_)
    return [x for value in values for x in all_literal_values(value)]


def eval_forward_ref(type_):
    try:
        return type_._evaluate(core_types.__dict__, None, set())
    except TypeError:
        # for older python (3.7 at least)
        return type_._evaluate(core_types.__dict__, None)


def main():
    schema_union = core_types.Schema
    assert get_origin(schema_union) is Union, 'expected pydantic_core._types.Schema to be a union'
    schema = union_schema(schema_union)
    schema['ref'] = 'root-schema'

    python_code = (
        f'# this file is autogenerated by generate_self_schema.py, DO NOT edit manually\n'
        f'{pformat(schema)}'
    )
    python_code = black.format_file_contents(python_code, fast=False, mode=black.FileMode())
    SAVE_PATH.write_text(python_code)
    print(f'Self schema definition written to {SAVE_PATH}')


if __name__ == '__main__':
    main()
