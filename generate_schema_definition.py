"""
This script generates the schema for the schema - e.g.
a definition of what inputs can be provided to `SchemaValidator()`.

The schema is generated from `pydantic_core/_types.py`.
"""
import re
from pprint import pformat
from typing import List, Dict, Any
from datetime import date, datetime, time
from pathlib import Path

import black

from pydantic.typing import (
    ForwardRef,
    all_literal_values,
    evaluate_forwardref,
    get_origin,
    is_callable_type,
    is_literal_type,
    is_typeddict,
    is_union,
)

from pydantic_core import _types as core_types

THIS_DIR = Path(__file__).parent
SAVE_PATH = THIS_DIR / 'src' / 'schema_definition.py'


# the validator for referencing schema (Schema is used recursively, so has to use a reference)
schema_ref_validator = {'type': 'recursive-ref', 'schema_ref': 'root-schema'}


def get_schema(obj):
    if isinstance(obj, str):
        return obj
    elif obj in (datetime, date, time, bool, int, float, str):
        return obj.__name__
    elif is_literal_type(obj):
        return {'type': 'literal', 'expected': list(all_literal_values(obj))}
    elif is_typeddict(obj):
        return type_dict_schema(obj)
    elif is_callable_type(obj):
        # todo
        return 'any'
    elif obj == Any:
        return 'any'
    elif obj == type:
        # todo
        return 'any'

    origin = get_origin(obj)
    assert origin is not None, f'origin cannot be None, obj={obj}'
    if is_union(origin):
        return union_schema(obj)
    if issubclass(origin, List):
        return {'type': 'list', 'items_schema': get_schema(obj.__args__[0])}
    if issubclass(origin, Dict):
        return {
            'type': 'dict',
            'keys_schema': get_schema(obj.__args__[0]),
            'values_schema': get_schema(obj.__args__[1]),
        }
    else:
        # debug(obj)
        raise TypeError(f'Unknown type: {obj!r}')


def type_dict_schema(typed_dict):
    required_keys = typed_dict.__required_keys__
    fields = {}
    if typed_dict.__name__ == 'Schema':
        return {'type': 'typed-dict', 'fields': fields}

    for field_name, field_type in typed_dict.__annotations__.items():
        required = field_name in required_keys
        schema = None
        if type(field_type) == ForwardRef:
            fr_arg = field_type.__forward_arg__
            if 'Schema' == fr_arg or '[Schema]' in fr_arg:
                fr_arg, matched = re.subn(r'Required\[(.+)]', r'\1', fr_arg)
                if matched:
                    required = True

                fr_arg, matched = re.subn(r'NotRequired\[(.+)]', r'\1', fr_arg)
                if matched:
                    required = False

                if fr_arg == 'Schema':
                    schema = schema_ref_validator
                elif fr_arg == 'List[Schema]':
                    schema = {'type': 'list', 'items_schema': schema_ref_validator}
                else:
                    raise ValueError(f'Unknown Schema forward ref: {fr_arg}')
            else:
                field_type = evaluate_forwardref(field_type, {}, {})

        if schema is None:
            if get_origin(field_type) == core_types.Required:
                required = True
                field_type = field_type.__args__[0]
            if get_origin(field_type) == core_types.NotRequired:
                required = False
                field_type = field_type.__args__[0]

            schema = get_schema(field_type)

        fields[field_name] = {'schema': schema, 'required': required}

    return {'type': 'typed-dict', 'description': typed_dict.__name__, 'fields': fields}


def union_schema(union_type):
    return {'type': 'union', 'choices': [get_schema(arg) for arg in union_type.__args__]}


def main():
    schema_union = core_types.Schema
    assert is_union(get_origin(schema_union)), 'expected pydantic_core._types.Schema to be a union'
    schema = union_schema(schema_union)
    schema['ref'] = 'root-schema'

    python_code = (
        f'# this file is autogenerated by generate_schema_definition.py, DO NOT edit manually\n'
        f'{pformat(schema)}'
    )
    python_code = black.format_file_contents(python_code, fast=False, mode=black.FileMode())
    SAVE_PATH.write_text(python_code)
    print(f'Schema definition written to {SAVE_PATH}')


if __name__ == '__main__':
    main()
